

# 计算机网络


## OSI
- 应用层
- 表示层
- 会话层
- 传输层
- 网络层
- 数据链路层
- 物理层 

## TCP-IP
- 应用层：
    应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族 内预存了各类通用的应用服务。比如，FTP（FileTransfer
    Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。HTTP 协议也处于该层。

- 传输层：
    传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。

- 网络层：
        网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。

- 链路层：
    用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。

## IP协议
- 位于网络层
- 作用：把数据包发送给对方
- 要素： MAC地址和IP地址
    - MAC: 网卡所属的固定地址。一般不变。
    - IP: 指明了节点被分配到的地址。IP地址可变。IP 间的通信依赖MAC地址。
- 中转：采用 ARP 协议（Address Resolution Protocol）。ARP是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。

## TCP协议
- TCP 位于传输层，提供一种面向连接的、可靠的字节流服务
- 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP
- TCP 使用校验和，确认和重传机制来保证可靠传输
- TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复
- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制
- TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。

## 三次握手与四次挥手
### 三次握手
- 三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。
- 三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。
1. 第一次握手(SYN=1, seq=x):
客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。
发送完毕后，客户端进入 SYN_SEND 状态。
2. 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。
3. 第三次握手(ACK=1，ACKnum=y+1)客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1
发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。

### 四次挥手
- TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。

1. 第一次挥手(FIN=1，seq=x)
假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进入 FIN_WAIT_1 状态。
2. 第二次挥手(ACK=1，ACKnum=x+1)服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。
3. 第三次挥手(FIN=1，seq=y)服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。
4.  第四次挥手(ACK=1，ACKnum=y+1)。客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。

### TCP 流量控制与拥塞机制
- 流量控制
    <!-- 1. 目的：防止分组丢失。发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。根据接收端能力来决定发送端的速度的机制叫做流量控制。
    2. 窗口大小：接收端向发送端主机通知自己可以接受的数据的大小。这个大小限制叫做窗口大小。
    3. 接收端将自己可以接受的缓冲区大小放TCP头部窗口大小字段。
    4. 由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。
    5. 死锁：当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。 -->
    - 流量控制概念

    接收端处理数据的速度是有限的，如果发送方的速度太快，就会把缓冲区打满。这个时候如果继续发送数据，就会导致丢包等一系列连锁反应。 所以 TCP 支持根据接收端能力来决定发送端的发送速度。这个机制叫做流控制。
    - 流控制与窗口大小

    接收端主机向发送端主机通知自己可以接收数据的大小，该大小限度就被称作窗口大小。窗口大小的值就是由接收端主机决定的。
    
    - 窗口大小扩大因子M

    实际的窗口大小是窗口字段的值左移M位

    

- 拥塞控制和流量控制的区别
    1. 拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。
    2. 流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。

- TCP 拥塞控制：
    - 慢开始

        发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。
        慢开始思路: 不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。
        - 初始化时 cwnd = 1.
        - 每当接收到一个ACK， cwnd ++， 线性上升
        - 每经过一个RTT, cwnd = cwnd*2， 指数上升
        - 阈值ssthreash(slow start threshold)是一个上线，当cwnd > ssthresh时就会进入拥塞避免算法。
    
    - 拥塞避免算法

        拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT(Round-Trip Time) 就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。 
        - 每当收到一个ACK， cwnd = cwnd + 1/cwnd
        - 每当过了一个RTT, cwnd = cwdn +1
        - 拥塞发生，当发生丢包进行数据包重传的时候，表示网络已经拥塞。
            1. 超时重传时间是以 RTO （Retransmission Timeout 超时重传时间）表示。
            2. ssthresh = cwnd /2
            3. cwnd 重置为 1
        - 核心：乘法减小（Multiplicative Decrease）和加法增大（Additive Increase）
        <img src="./images/network/yongsekongzhi.jpg" width="100%">
    - 快重传算法

        接收方收到收到一个失序的报文段后就立即发出重复确认。 收到三个duplicate AKG后就重传，不用等到RTO超时。
        1. ssthresh = cwnd /2
        2. 进入快速恢复算法.
        <img src="./images/network/kuaichongchuan.jpg" width="100%">
    
    - 快速恢复算法(至少收到三个duplicate AKGS,网络不是那么糟糕)
        
        当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞）。但是接下去并不执行慢开始算法。考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大。如

        <img src="./images/network/kuaisuhuifu.jpg" width="100%">

    - TCP如何保证安全
        -  停止等待协议
            1. 每发送完一个分组，就停止发送，等待对方确认，收到确认后再发送下一个分组。
            2. 每发送一个分组就设置一个超时计时器，超时之后就重传。
            3. 确认丢失：
            确认丢失A要重传，B要再次确认
            4. 确认迟到：
                对于确认迟到，A要重传分组，对收到的迟到确认丢弃。B要再次确认分组，对收到的重复分组丢弃。
        - 连续 ARQ协议